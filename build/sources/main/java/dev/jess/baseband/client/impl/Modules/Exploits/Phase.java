package dev.jess.baseband.client.impl.Modules.Exploits;

import dev.jess.baseband.client.api.Module.Category;
import dev.jess.baseband.client.api.Module.Module;
import net.minecraft.client.Minecraft;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.CPacketConfirmTeleport;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.network.play.server.SPacketPlayerPosLook;

import java.awt.*;

public class Phase extends Module {
	int tpid = 0;
	boolean clipped = false;

	public Phase() {
		super("Phase", "Desciption.", Category.EXPLOITS, new Color(208, 201, 132, 255).getRGB());
	}

	public static boolean isPlayerClipped() {

		return ! (mc.world.getCollisionBoxes(mc.player, mc.player.getEntityBoundingBox()).isEmpty());

	}

	public static double[] forward(final double speed) {
		float forward = Minecraft.getMinecraft().player.movementInput.moveForward;
		float side = Minecraft.getMinecraft().player.movementInput.moveStrafe;
		float yaw = Minecraft.getMinecraft().player.prevRotationYaw + (Minecraft.getMinecraft().player.rotationYaw - Minecraft.getMinecraft().player.prevRotationYaw) * Minecraft.getMinecraft().getRenderPartialTicks();
		if (forward != 0.0f) {
			if (side > 0.0f) {
				yaw += ((forward > 0.0f) ? - 45 : 45);
			} else if (side < 0.0f) {
				yaw += ((forward > 0.0f) ? 45 : - 45);
			}
			side = 0.0f;
			if (forward > 0.0f) {
				forward = 1.0f;
			} else if (forward < 0.0f) {
				forward = - 1.0f;
			}
		}
		final double sin = Math.sin(Math.toRadians(yaw + 90.0f));
		final double cos = Math.cos(Math.toRadians(yaw + 90.0f));
		final double posX = forward * speed * cos + side * speed * sin;
		final double posZ = forward * speed * sin - side * speed * cos;
		return new double[]{posX, posZ};
	}

	public static CPacketPlayer doBounds(String mode, boolean send) {

		double[] dir;
		CPacketPlayer packet = new CPacketPlayer.PositionRotation(0, 0, 0, 0, 0, false);

		switch (mode) {

			case "Up":
				packet = new CPacketPlayer.PositionRotation(mc.player.posX, mc.player.posY + 69420, mc.player.posZ, mc.player.rotationYaw, mc.player.rotationPitch, false);
				break;
			case "Down":
				packet = new CPacketPlayer.PositionRotation(mc.player.posX, mc.player.posY - 69420, mc.player.posZ, mc.player.rotationYaw, mc.player.rotationPitch, false);
				break;
			case "Zero":
				packet = new CPacketPlayer.PositionRotation(mc.player.posX, 0, mc.player.posZ, mc.player.rotationYaw, mc.player.rotationPitch, false);
				break;
			case "Min":
				packet = new CPacketPlayer.PositionRotation(mc.player.posX, mc.player.posY + 100, mc.player.posZ, mc.player.rotationYaw, mc.player.rotationPitch, false);
				break;
			case "Alternate":
				if (mc.player.ticksExisted % 2 == 0)
					packet = new CPacketPlayer.PositionRotation(mc.player.posX, mc.player.posY + 69420, mc.player.posZ, mc.player.rotationYaw, mc.player.rotationPitch, false);
				else
					packet = new CPacketPlayer.PositionRotation(mc.player.posX, mc.player.posY - 69420, mc.player.posZ, mc.player.rotationYaw, mc.player.rotationPitch, false);
				break;
			case "Forward":
				dir = forward(67);
				packet = new CPacketPlayer.PositionRotation(mc.player.posX + dir[0], mc.player.posY + 33.4, mc.player.posZ + dir[1], mc.player.rotationYaw, mc.player.rotationPitch, false);
				break;
			case "Flat":
				dir = forward(100);
				packet = new CPacketPlayer.PositionRotation(mc.player.posX + dir[0], mc.player.posY, mc.player.posZ + dir[1], mc.player.rotationYaw, mc.player.rotationPitch, false);
				break;
			case "Constrict":
				dir = forward(67);
				packet = new CPacketPlayer.PositionRotation(mc.player.posX + dir[0], mc.player.posY + (mc.player.posY > 64 ? - 33.4 : 33.4), mc.player.posZ + dir[1], mc.player.rotationYaw, mc.player.rotationPitch, false);
				break;
		}
		mc.player.connection.sendPacket(packet);
		return packet;
	}


	public void tick() {
		clipped = isPlayerClipped();

		if ((((mc.player.collidedHorizontally || mc.gameSettings.keyBindSneak.isKeyDown()))
				&& (clipped)
				|| (mc.gameSettings.keyBindSprint.isKeyDown()) && mc.player.collidedHorizontally))
			packetFly();
	}

	void packetFly() {

		double[] clip = forward(0.0624);

		if (mc.gameSettings.keyBindSneak.isKeyDown() && mc.player.onGround)
			tp(0d, - 0.0624, 0d, false);
		else
			tp(clip[0], 0, clip[1], true);


	}

	void tp(double x, double y, double z, boolean onGround) {

		double[] dir = forward(- 0.0312);
		mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX + dir[0], mc.player.posY, mc.player.posZ + dir[1], onGround)); // move back a bit
		mc.player.connection.sendPacket(new CPacketPlayer.Position((true ? (x / 2) : x) + mc.player.posX, y + mc.player.posY, (true ? (z / 2) : z) + mc.player.posZ, onGround));
		mc.player.connection.sendPacket(new CPacketConfirmTeleport(tpid - 1));
		mc.player.connection.sendPacket(new CPacketConfirmTeleport(tpid));
		mc.player.connection.sendPacket(new CPacketConfirmTeleport(tpid + 1));
		doBounds("Down", true);


	}


	public boolean onPacketSend(Packet<?> packet) {
		if (packet instanceof CPacketPlayer.PositionRotation || packet instanceof CPacketPlayer.Position) {
			tpid++;
		}
		return false;
	}


	public boolean onPacketReceive(Packet<?> packet) {
		if (packet.getClass() == SPacketPlayerPosLook.class) {
			tpid = ((SPacketPlayerPosLook) packet).getTeleportId();
		}
		return false;
	}
}
