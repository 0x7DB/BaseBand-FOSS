package dev.jess.baseband.client.impl.Modules.Exploits;

import dev.jess.baseband.client.api.Main.BaseBand;
import dev.jess.baseband.client.api.Module.Category;
import dev.jess.baseband.client.api.Module.Module;

import java.awt.*;
import java.util.ArrayList;
import java.util.Arrays;

import dev.jess.baseband.client.api.Settings.Setting;
import dev.jess.baseband.client.mixin.Mixin.ISPacketPlayerPosLook;
import net.minecraft.client.gui.GuiDownloadTerrain;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.CPacketConfirmTeleport;
import net.minecraft.network.play.client.CPacketPlayer.Position;
import net.minecraft.network.play.server.SPacketPlayerPosLook;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.MathHelper;


public class PacketFly extends Module {
    public PacketFly() {
        super("PacketFly", "mmax don't kill me pls", Category.EXPLOITS, new Color(165, 132, 208,255).getRGB());
        BaseBand.settingsManager.rSetting(bound);
        BaseBand.settingsManager.rSetting(cancelPacket);
        BaseBand.settingsManager.rSetting(tpAccept);
        BaseBand.settingsManager.rSetting(edgeEnable);
        BaseBand.settingsManager.rSetting(noclip);
        BaseBand.settingsManager.rSetting(slide);
        BaseBand.settingsManager.rSetting(jitterAmount);
        BaseBand.settingsManager.rSetting(boundAmount);
        BaseBand.settingsManager.rSetting(speed);


    }


    private final Setting bound = new Setting("Bound", this, true);
    private final Setting cancelPacket = new Setting("CancelPacket", this, true);
    private final Setting tpAccept = new Setting("TPAccept", this, true);
    private final Setting edgeEnable = new Setting("EdgeEnable", this, true);
    private final Setting noclip = new Setting("NoClip", this, true);
    private final Setting slide = new Setting("Slide", this, 0.5,0,1,false);
    private final Setting jitterAmount = new Setting("JitterAmount", this, 1,0,3,false);
    private final Setting boundAmount = new Setting("BoundAmount", this, 555,-1337,1337,false);

    private final Setting speed = new Setting("Speed", this, 0.01,0.01,0.1,false);





    public void renderWorld(){
        this.setMcHudMeta(""+boundAmount.getValBoolean());
    }

    boolean cancelling = true;
    int teleportId;
    ArrayList<Position> packets = new ArrayList<>();

    public void disable() {
            if (noclip.getValBoolean()) {
                PacketFly.mc.player.noClip = false;
            }
    }

    public void enable() {
            if (noclip.getValBoolean()) {
                PacketFly.mc.player.noClip = true;
            }
            teleportId = 0;
    }

    public static double[] forward(double speed) {
        float forward = mc.player.movementInput.moveForward;
        float side = mc.player.movementInput.moveStrafe;
        float yaw = mc.player.prevRotationYaw + (mc.player.rotationYaw - mc.player.prevRotationYaw) * mc.getRenderPartialTicks();

        if (forward != 0.0F) {
            if (side > 0.0F) {
                yaw += (float) (forward > 0.0F ? -45 : 45);
            } else if (side < 0.0F) {
                yaw += (float) (forward > 0.0F ? 45 : -45);
            }

            side = 0.0F;
            if (forward > 0.0F) {
                forward = 1.0F;
            } else if (forward < 0.0F) {
                forward = -1.0F;
            }
        }

        double sin = Math.sin(Math.toRadians(yaw + 90.0F));
        double cos = Math.cos(Math.toRadians(yaw + 90.0F));
        double posX = (double) forward * speed * cos + (double) side * speed * sin;
        double posZ = (double) forward * speed * sin - (double) side * speed * cos;

        return new double[] { posX, posZ};
    }


    public void tick() {
            if (shouldFly()) {
                cancelling = false;
                double[] forward = forward(getSpeed() * getJitter());
                double up = PacketFly.mc.gameSettings.keyBindJump.isKeyDown() ? 0.0233D : (PacketFly.mc.gameSettings.keyBindSneak.isKeyDown() ? -0.0233D : 1.0E-6D);
                double[] playerPos = toPlayerPos(forward[0], up, forward[1]);

                PacketFly.mc.player.setVelocity(forward[0], up, forward[1]);
                Position packetPlayer = new Position(playerPos[0], playerPos[1], playerPos[2], PacketFly.mc.player.onGround);

                PacketFly.mc.player.connection.sendPacket(packetPlayer);
                packets.add(packetPlayer);
                PacketFly.mc.player.setPosition(playerPos[0], playerPos[1], playerPos[2]);
                if (bound.getValBoolean()) {
                    Position bounds = new Position(playerPos[0], boundAmount.getValDouble(), playerPos[2], PacketFly.mc.player.onGround);

                    PacketFly.mc.player.connection.sendPacket(bounds);
                    packets.add(bounds);
                }

                ++teleportId;
                if (tpAccept.getValBoolean()) {
                    PacketFly.mc.player.connection.sendPacket(new CPacketConfirmTeleport(teleportId - 1));
                    PacketFly.mc.player.connection.sendPacket(new CPacketConfirmTeleport(teleportId));
                    PacketFly.mc.player.connection.sendPacket(new CPacketConfirmTeleport(teleportId + 1));
                }

                cancelling = true;
            }
    }


    @Override
    public boolean onPacketSend(Packet<?> packet2) {
        if (packet2 instanceof Position && cancelPacket.getValBoolean()) {
            return cancelling;
        }
        return false;
    }

    @Override
    public boolean onPacketReceive(Packet<?> packet5) {
        SPacketPlayerPosLook packet2 = (SPacketPlayerPosLook) packet5;
        ISPacketPlayerPosLook inter = (ISPacketPlayerPosLook) packet2;

        if (PacketFly.mc.player.isEntityAlive() && PacketFly.mc.world.isBlockLoaded(new BlockPos(PacketFly.mc.player.posX, PacketFly.mc.player.posY, PacketFly.mc.player.posZ)) && !(PacketFly.mc.currentScreen instanceof GuiDownloadTerrain)) {
            if (teleportId <= 0) {
                teleportId = packet2.getTeleportId();
            } else {
                inter.setX(MathHelper.clampedLerp(Math.min(PacketFly.mc.player.posX, packet2.getX()), Math.max(PacketFly.mc.player.posX, packet2.getX()), slide.getValDouble()));
                inter.setY(MathHelper.clampedLerp(Math.min(PacketFly.mc.player.getEntityBoundingBox().minY, packet2.getY()), Math.max(PacketFly.mc.player.getEntityBoundingBox().minY, packet2.getY()), slide.getValDouble()));
                inter.setZ(MathHelper.clampedLerp(Math.min(PacketFly.mc.player.posZ, packet2.getZ()), Math.max(PacketFly.mc.player.posZ, packet2.getZ()), slide.getValDouble()));
            }
        }

        return false;
    }

   
    

    double getSpeed() {
        return !PacketFly.mc.gameSettings.keyBindJump.isKeyDown() && !PacketFly.mc.gameSettings.keyBindSneak.isKeyDown() ? speed.getValDouble() : 0.0D;
    }

    double[] toPlayerPos(double x, double y, double z) {
        return new double[] { PacketFly.mc.player.posX + x, PacketFly.mc.player.posY + y, PacketFly.mc.player.posZ + z};
    }

    double getJitter() {
        return Math.floor(Math.random() * jitterAmount.getValDouble() - ((Number) jitterAmount.getMin()).doubleValue() + 1.0D) + ((Number) jitterAmount.getMin()).doubleValue();
    }

    boolean isOnEdge() {
        boolean verticalFlying = PacketFly.mc.gameSettings.keyBindJump.isKeyDown() || PacketFly.mc.gameSettings.keyBindSneak.isKeyDown();

        return PacketFly.mc.player.collidedHorizontally || verticalFlying;
    }

    boolean shouldFly() {
        return !edgeEnable.getValBoolean() || isOnEdge();
    }


}
